let s:matlab_path = []
let s:popup_id = -1


function! matlabutils#initialise() abort
    call matlabutils#set_path()

    nnoremap <buffer><silent> gf :call matlabutils#goto_file()<CR>
    
    if has('popupwin')   " excludes nvim (or ancient vim, I guess)
        nnoremap <buffer><silent> K  :call matlabutils#show_or_hide_docs()<CR>
        nnoremap <buffer><silent><expr> <C-j>
                    \ matlabutils#popup_is_active() ? ":call matlabutils#popup_scroll(2)<CR>" : "<C-j>"
        nnoremap <buffer><silent><expr> <C-k>
                    \ matlabutils#popup_is_active() ? ":call matlabutils#popup_scroll(-2)<CR>" : "<C-k>"
    endif
endfunction


function! matlabutils#set_path() abort
    " The total Matlab path has three components: one is userpath, one is the
    " MATLABPATH environment variable, and the last comes from this file.
    " Right now we only use this file, which should be considered a bug.
    let pathdef_m_file = g:matlab_root . '/toolbox/local/pathdef.m'
    let lines = readfile(pathdef_m_file)

    " The entries are helpfully delimited for us in this file, which is
    " automatically generated by Matlab.
    let entries_start = index(lines, '%%% BEGIN ENTRIES %%%')
    let entries_end   = index(lines, '%%% END ENTRIES %%%')
    if (entries_start == -1) || (entries_end == -1)
        echomsg('matlab-utils: pathdef.m could not be parsed')
    endif
    let paths = slice(lines, entries_start + 1, entries_end)
    
    call map(paths, {_, val -> matlabutils#parse_path(val)})
    call filter(paths, {_, val -> !empty(val)})
    
    let s:matlab_path = paths
endfunction


function! matlabutils#get_path() abort
    return s:matlab_path
endfunction


function! matlabutils#parse_path(line) abort
    " Check for a standalone folder
    let pattern_standalone = '\m^\s\+''\(.\+\):'', \.\.\.$'
    let line_match = matchlist(a:line, pattern_standalone)
    if !empty(line_match)
        return simplify(line_match[1])
    endif

    " Check for matlabroot paths
    let pattern_matlabroot = '\m^\s\+matlabroot,''\(.\+\):'', \.\.\.$'
    let line_match = matchlist(a:line, pattern_matlabroot)
    if !empty(line_match)
        return simplify(g:matlab_root . line_match[1])
    endif

    " Failed to parse
    return ''
endfunction


" Search for a function in the Matlab path.
function! matlabutils#find_file(function_name) abort
    if empty(s:matlab_path) | return | endif

    " Figure out what the correct filename for the script is, relative to a
    " directory in the Matlab path
    if match(a:function_name, '\v\.') == -1
        " No dots, i.e. an ordinary function
        " expm -> expm.m
        let script_name = a:function_name . '.m'
    else
        " Has dots, i.e. a package (or possibly a class, but that remains
        " unimplemented)
        " foo.bar.baz -> +foo/+bar/baz.m
        let paths = split(a:function_name, '\v\.')
        call map(paths, {idx, val -> 
                    \ idx == len(paths) - 1 ? val . '.m' : '+' . val})
        let script_name = join(paths, '/')
    endif

    " Return the path directly if found
    for directory in s:matlab_path
        let candidate_path = directory . '/' . script_name
        if filereadable(candidate_path)
            return simplify(candidate_path)
        endif
    endfor
endfunction


function! matlabutils#goto_file() abort
    let function_name = matlabutils#get_function_under_cursor()

    if !empty(function_name)
        let file_name = matlabutils#find_file(function_name)
        if !empty(file_name)
            unsilent execute 'edit ' . file_name
        else
            echomsg '.m file for function ''' . function_name . ''' not found'
        endif
    endif
endfunction


function! matlabutils#get_function_under_cursor() abort
    " We don't necessarily want to override iskeyword here (because that
    " affects the behaviour of w and other commands), so we perform some
    " manual parsing.
    let line = getline('.')
    let col  = getpos('.')[2]   " current cursor column

    let name_start = col - 1
    while name_start >= 0 && line[name_start] =~ '\v[A-Za-z0-9_.]'
        let name_start = name_start - 1
    endwhile
    let name_start = name_start + 1

    let name_end = col - 1
    while name_end < len(line) && line[name_end] =~ '\v[A-Za-z0-9_.]'
        let name_end = name_end + 1
    endwhile

    return slice(line, name_start, name_end)
endfunction


" Obtains header comments from a given Matlab file. The header comments may be
" placed either at the very top of the file, or immediately after the function
" definition.
function! matlabutils#get_doc_from_file(fname) abort
    let lines = readfile(a:fname)

    " Skip forward to find the first line that isn't whitespace-only
    let start_lnum = 0
    while empty(trim(lines[start_lnum]))
        let start_lnum = start_lnum + 1
    endwhile
    " If it's the function definition, start on the line immediately after it
    if lines[start_lnum] =~ '\v^\s*function.+$'
        let start_lnum = start_lnum + 1
    endif

    " Search for the first line that isn't whitespace or comments
    let end_lnum = start_lnum
    while lines[end_lnum] =~ '\v^\s*(\%.*)?$'
        let end_lnum = end_lnum + 1
    endwhile
    let end_lnum = end_lnum - 1
    " Backtrack to remove trailing whitespace-only lines
    while lines[end_lnum] =~ '\v^\s*$'
        let end_lnum = end_lnum - 1
    endwhile

    let lines = slice(lines, start_lnum, end_lnum + 1)
    call map(lines, {_, val -> substitute(val, '\v^\s*\%\s*', '', '')})
    return lines
endfunction


function matlabutils#show_or_hide_docs() abort
    " Show docs if popup is not active
    if s:popup_id == -1
        let function_name = matlabutils#get_function_under_cursor()
        if empty(function_name) | return | endif

        let file_name = matlabutils#find_file(function_name)
        if empty(file_name)
            echomsg '.m file for function ''' . function_name . ''' not found'
            return
        endif

        let docs = matlabutils#get_doc_from_file(file_name)
        if empty(docs)
            echomsg 'no documentation found in file ' . file_name
        else
            let s:popup_id = popup_atcursor(docs, {
                        \ 'padding': [0, 1, 0, 1],
                        \ 'border': [1, 1, 1, 1],
                        \ })
        endif

    " Hide docs if popup is active
    else
        call popup_close(s:popup_id)
        let s:popup_id = -1
    endif
endfunction


function matlabutils#popup_is_active() abort
    return s:popup_id != -1
endfunction


function matlabutils#popup_scroll(val) abort
    if s:popup_id == -1 | return | endif

    " It seems preferable to use C-e and C-y, because (unlike the buildin
    " popup_setoptions function) these don't change the width of the popup
    " window.
    "
    " If a:val is negative (i.e. scrolling up), we can just use C-y as many
    " times as we like, as it can't go beyond the top.
    if a:val < 0
        let i = 0
        while i < -a:val
            call win_execute(s:popup_id, "normal! \<C-y>")
            let i += 1
        endwhile
    " If a:val is positive (i.e. scrolling down), then we have to make sure we
    " don't go beyond the last line (since C-e can do that by default).
    elseif a:val > 0
        let pos = popup_getpos(s:popup_id)
        let cur_last_line = pos.lastline
        let max_last_line = str2nr(trim(win_execute(s:popup_id, "echo line ('$')")))
        let i = 0
        while i < a:val && cur_last_line < max_last_line
            call win_execute(s:popup_id, "normal! \<C-e>")
            let i += 1
            let cur_last_line += 1
        endwhile
    endif
endfunction
