let s:matlab_path = []


function! matlabutils#initialise() abort
    call matlabutils#set_path()

    nnoremap <buffer><silent> gf :call matlabutils#goto_file()<CR>
endfunction


function! matlabutils#set_path() abort
    " The total Matlab path has three components: one is userpath, one is the
    " MATLABPATH environment variable, and the last comes from this file.
    " Right now we only use this file, which should be considered a bug.
    let pathdef_m_file = g:matlab_root . '/toolbox/local/pathdef.m'
    let lines = readfile(pathdef_m_file)

    " The entries are helpfully delimited for us in this file, which is
    " automatically generated by Matlab.
    let entries_start = index(lines, '%%% BEGIN ENTRIES %%%')
    let entries_end   = index(lines, '%%% END ENTRIES %%%')
    if (entries_start == -1) || (entries_end == -1)
        echomsg('matlab-utils: pathdef.m could not be parsed')
    endif
    let paths = slice(lines, entries_start + 1, entries_end)
    
    call map(paths, {_, val -> matlabutils#parse_path(val)})
    call filter(paths, {_, val -> !empty(val)})
    
    let s:matlab_path = paths
endfunction


function! matlabutils#get_path() abort
    return s:matlab_path
endfunction


function! matlabutils#parse_path(line) abort
    " Check for a standalone folder
    let pattern_standalone = '\m^\s\+''\(.\+\):'', \.\.\.$'
    let line_match = matchlist(a:line, pattern_standalone)
    if !empty(line_match)
        return simplify(line_match[1])
    endif

    " Check for matlabroot paths
    let pattern_matlabroot = '\m^\s\+matlabroot,''\(.\+\):'', \.\.\.$'
    let line_match = matchlist(a:line, pattern_matlabroot)
    if !empty(line_match)
        return simplify(g:matlab_root . line_match[1])
    endif

    " Failed to parse
    return ''
endfunction


" Search for a function in the Matlab path.
"
" Note that Matlab's path resolution is horrendous. Like, ABSOLUTELY ATROCIOUS.
" See https://uk.mathworks.com/help/matlab/matlab_oop/scoping-classes-with-packages.html
" Therefore, this plugin doesn't attempt to get it right (at this point in
" time, at least). If there are clashes (such as those described in the link
" above), this plugin will not necessarily resolve them in the correct order
" as stipulated there. You have been warned.
" The solution to this, as far as I'm concerned, is for the programmer to:
"    (a) not use Matlab. Given that you're reading this, that is unlikely. But
"        it should be borne in mind for other projects.
"    (b) be very careful about avoiding naming conflicts.
function! matlabutils#find_file(function_name) abort
    if empty(s:matlab_path) | return | endif

    " Deal with functions without dots, i.e. just look for the .m files
    if match(a:function_name, '\v\.') == -1
        for directory in s:matlab_path
            let script_name = a:function_name . '.m'
            let candidate_path = directory . '/' . script_name
            if filereadable(candidate_path)
                return simplify(candidate_path)
            endif
        endfor
    else
        for directory in s:matlab_path
            " foo.bar.baz -> +foo/+bar/baz.m
            let paths = split(a:function_name, '\v\.')
            call map(paths, {idx, val -> 
                        \ idx == len(paths) - 1 ? val . '.m' : '+' . val})
            let script_name = join(paths, '/')
            let candidate_path = directory . '/' . script_name
            echomsg(candidate_path)
            if filereadable(candidate_path)
                return simplify(candidate_path)
            endif
        endfor
    endif

    echomsg '.m file for function ''' . a:function_name . ''' not found'
    return ''
endfunction


function! matlabutils#goto_file() abort
    " Error messages are handled in find_file() so we have none here.
    let function_name = matlabutils#get_function_under_cursor()
    if !empty(function_name)
        let file_name = matlabutils#find_file(function_name)
        if !empty(file_name)
            unsilent execute 'edit ' . file_name
        endif
    endif
endfunction


function! matlabutils#get_function_under_cursor() abort
    " We don't necessarily want to override iskeyword here (because that
    " affects the behaviour of w and other commands), so we perform some
    " manual parsing.
    let line = getline('.')
    let col  = getpos('.')[2]   " current cursor column

    let name_start = col - 1
    while name_start >= 0 && line[name_start] =~ '\v[A-Za-z0-9_.]'
        let name_start = name_start - 1
    endwhile
    let name_start = name_start + 1

    let name_end = col - 1
    while name_end < len(line) && line[name_end] =~ '\v[A-Za-z0-9_.]'
        let name_end = name_end + 1
    endwhile

    return slice(line, name_start, name_end)
endfunction
